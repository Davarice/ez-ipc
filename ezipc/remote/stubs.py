"""Stub Module providing the Attributes and Method Signatures of a Remote.

Required by Handlers module for Automatic Documentation.
"""

from asyncio import (
    AbstractEventLoop,
    Future,
    Queue,
    StreamReader,
    StreamWriter,
    Task,
)
from collections import Counter
from datetime import datetime as dt
from typing import Callable, Dict, List, Union

from .connection import Connection


class Remote:
    eventloop: AbstractEventLoop = ...
    instr: StreamReader = ...
    outstr: StreamWriter = ...
    connection: Connection = ...
    addr: str = ...
    port: int = ...
    hooks_notif: Dict[str, Callable] = ...
    hooks_request: Dict[str, Callable] = ...
    futures: Dict[str, Future] = ...
    lines: Queue = ...
    total_sent: Counter = ...
    total_recv: Counter = ...
    group: set = ...
    opened: dt = ...
    startup: dt = ...
    def __init__(
        self,
        eventloop: AbstractEventLoop,
        instr: StreamReader,
        outstr: StreamWriter,
        group: set = None
    ): ...
    def host(self) -> str: ...
    def is_secure(self) -> bool: ...
    def open(self) -> bool: ...
    def _add_default_hooks(self): ...
    async def enable_rsa(self) -> bool: ...
    async def get_line(self) -> str: ...
    async def process_line(self, line: str, tasks: List[Task]): ...
    def handle_request(self, method: str) -> Callable: ...
    def handle_response(self, **kw) -> Callable: ...
    def hook_notif(self, method: str, func: Callable = None): ...
    def hook_request(self, method: str, func: Callable = None): ...
    def close(self): ...
    async def helper(self, queue: Queue): ...
    async def loop(self, helper_count: int = 5): ...
    async def notif(
        self,
        meth: str,
        params: Union[dict, list] = None,
        nohandle: bool = False
    ): ...
    async def request(
        self,
        meth: str,
        params: Union[dict, list] = None,
        *,
        callback: Callable = None,
        nohandle: bool = False
    ) -> Future: ...
    async def request_wait(
        self,
        meth: str,
        params: Union[dict, list] = None,
        default=None,
        *,
        callback: Callable = None,
        nohandle: bool = False,
        timeout: int = 10,
        raise_remote_err: bool = False
    ) -> Union[dict, list]: ...
    async def respond(
        self,
        mid: str,
        method: str = None,
        *,
        err: dict = None,
        res: Union[dict, list] = None,
        nohandle: bool = False
    ): ...
    async def send(self, data: str): ...
    async def terminate(self, reason: str = None): ...
